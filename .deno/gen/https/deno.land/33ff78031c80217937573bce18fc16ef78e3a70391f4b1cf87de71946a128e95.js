// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// Copyright Joyent, Inc. and Node.js contributors. All rights reserved. MIT license.
import { kHandle, kKeyObject } from "./constants.ts";
import { ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE } from "../errors.ts";
import { notImplemented } from "../../_utils.ts";
import { Buffer } from "../../buffer.ts";
import { isAnyArrayBuffer, isArrayBufferView } from "../util/types.ts";
import { hideStackFrames } from "../errors.ts";
import { isCryptoKey as isCryptoKey_, isKeyObject as isKeyObject_, kKeyType } from "./_keys.ts";
const getArrayBufferOrView = hideStackFrames((buffer, name, encoding)=>{
    if (isAnyArrayBuffer(buffer)) {
        return buffer;
    }
    if (typeof buffer === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer.from(buffer, encoding);
    }
    if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, [
            "string",
            "ArrayBuffer",
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
    return buffer;
});
export function isKeyObject(obj) {
    return isKeyObject_(obj);
}
export function isCryptoKey(obj) {
    return isCryptoKey_(obj);
}
export class KeyObject {
    [kKeyType];
    [kHandle];
    constructor(type, handle){
        if (type !== "secret" && type !== "public" && type !== "private") {
            throw new ERR_INVALID_ARG_VALUE("type", type);
        }
        if (typeof handle !== "object") {
            throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
        }
        this[kKeyType] = type;
        Object.defineProperty(this, kHandle, {
            value: handle,
            enumerable: false,
            configurable: false,
            writable: false
        });
    }
    get type() {
        return this[kKeyType];
    }
    get asymmetricKeyDetails() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
        return undefined;
    }
    get asymmetricKeyType() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
        return undefined;
    }
    get symmetricKeySize() {
        notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
        return undefined;
    }
    static from(key) {
        if (!isCryptoKey(key)) {
            throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key);
        }
        notImplemented("crypto.KeyObject.prototype.from");
    }
    equals(otherKeyObject) {
        if (!isKeyObject(otherKeyObject)) {
            throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
        }
        notImplemented("crypto.KeyObject.prototype.equals");
    }
    export(_options) {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    }
}
export function createPrivateKey(_key) {
    notImplemented("crypto.createPrivateKey");
}
export function createPublicKey(_key) {
    notImplemented("crypto.createPublicKey");
}
function getKeyTypes(allowKeyObject, bufferOnly = false) {
    const types = [
        "ArrayBuffer",
        "Buffer",
        "TypedArray",
        "DataView",
        "string",
        "KeyObject",
        "CryptoKey"
    ];
    if (bufferOnly) {
        return types.slice(0, 4);
    } else if (!allowKeyObject) {
        return types.slice(0, 5);
    }
    return types;
}
export function prepareSecretKey(key, encoding, bufferOnly = false) {
    if (!bufferOnly) {
        if (isKeyObject(key)) {
            if (key.type !== "secret") {
                throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, "secret");
            }
            return key[kHandle];
        } else if (isCryptoKey(key)) {
            if (key.type !== "secret") {
                throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, "secret");
            }
            return key[kKeyObject][kHandle];
        }
    }
    if (typeof key !== "string" && !isArrayBufferView(key) && !isAnyArrayBuffer(key)) {
        throw new ERR_INVALID_ARG_TYPE("key", getKeyTypes(!bufferOnly, bufferOnly), key);
    }
    return getArrayBufferOrView(key, "key", encoding);
}
export function createSecretKey(_key, _encoding) {
    notImplemented("crypto.createSecretKey");
}
export default {
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    isKeyObject,
    isCryptoKey,
    KeyObject,
    prepareSecretKey
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjE2Ny4wL25vZGUvaW50ZXJuYWwvY3J5cHRvL2tleXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cblxuaW1wb3J0IHsga0hhbmRsZSwga0tleU9iamVjdCB9IGZyb20gXCIuL2NvbnN0YW50cy50c1wiO1xuaW1wb3J0IHtcbiAgRVJSX0NSWVBUT19JTlZBTElEX0tFWV9PQkpFQ1RfVFlQRSxcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gIEVSUl9JTlZBTElEX0FSR19WQUxVRSxcbn0gZnJvbSBcIi4uL2Vycm9ycy50c1wiO1xuaW1wb3J0IHsgbm90SW1wbGVtZW50ZWQgfSBmcm9tIFwiLi4vLi4vX3V0aWxzLnRzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEtleUZvcm1hdCxcbiAgS2V5VHlwZSxcbiAgUHJpdmF0ZUtleUlucHV0LFxuICBQdWJsaWNLZXlJbnB1dCxcbn0gZnJvbSBcIi4vdHlwZXMudHNcIjtcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCIuLi8uLi9idWZmZXIudHNcIjtcbmltcG9ydCB7IGlzQW55QXJyYXlCdWZmZXIsIGlzQXJyYXlCdWZmZXJWaWV3IH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMudHNcIjtcbmltcG9ydCB7IGhpZGVTdGFja0ZyYW1lcyB9IGZyb20gXCIuLi9lcnJvcnMudHNcIjtcbmltcG9ydCB7XG4gIGlzQ3J5cHRvS2V5IGFzIGlzQ3J5cHRvS2V5XyxcbiAgaXNLZXlPYmplY3QgYXMgaXNLZXlPYmplY3RfLFxuICBrS2V5VHlwZSxcbn0gZnJvbSBcIi4vX2tleXMudHNcIjtcblxuY29uc3QgZ2V0QXJyYXlCdWZmZXJPclZpZXcgPSBoaWRlU3RhY2tGcmFtZXMoXG4gIChidWZmZXIsIG5hbWUsIGVuY29kaW5nKTogQnVmZmVyID0+IHtcbiAgICBpZiAoaXNBbnlBcnJheUJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcImJ1ZmZlclwiKSB7XG4gICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIGlmICghaXNBcnJheUJ1ZmZlclZpZXcoYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICBuYW1lLFxuICAgICAgICBbXG4gICAgICAgICAgXCJzdHJpbmdcIixcbiAgICAgICAgICBcIkFycmF5QnVmZmVyXCIsXG4gICAgICAgICAgXCJCdWZmZXJcIixcbiAgICAgICAgICBcIlR5cGVkQXJyYXlcIixcbiAgICAgICAgICBcIkRhdGFWaWV3XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH0sXG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFzeW1tZXRyaWNLZXlEZXRhaWxzIHtcbiAgLyoqXG4gICAqIEtleSBzaXplIGluIGJpdHMgKFJTQSwgRFNBKS5cbiAgICovXG4gIG1vZHVsdXNMZW5ndGg/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBQdWJsaWMgZXhwb25lbnQgKFJTQSkuXG4gICAqL1xuICBwdWJsaWNFeHBvbmVudD86IGJpZ2ludCB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG1lc3NhZ2UgZGlnZXN0IChSU0EtUFNTKS5cbiAgICovXG4gIGhhc2hBbGdvcml0aG0/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBtZXNzYWdlIGRpZ2VzdCB1c2VkIGJ5IE1HRjEgKFJTQS1QU1MpLlxuICAgKi9cbiAgbWdmMUhhc2hBbGdvcml0aG0/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBNaW5pbWFsIHNhbHQgbGVuZ3RoIGluIGJ5dGVzIChSU0EtUFNTKS5cbiAgICovXG4gIHNhbHRMZW5ndGg/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBTaXplIG9mIHEgaW4gYml0cyAoRFNBKS5cbiAgICovXG4gIGRpdmlzb3JMZW5ndGg/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjdXJ2ZSAoRUMpLlxuICAgKi9cbiAgbmFtZWRDdXJ2ZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHR5cGUgS2V5T2JqZWN0VHlwZSA9IFwic2VjcmV0XCIgfCBcInB1YmxpY1wiIHwgXCJwcml2YXRlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5RXhwb3J0T3B0aW9uczxUIGV4dGVuZHMgS2V5Rm9ybWF0PiB7XG4gIHR5cGU6IFwicGtjczFcIiB8IFwic3BraVwiIHwgXCJwa2NzOFwiIHwgXCJzZWMxXCI7XG4gIGZvcm1hdDogVDtcbiAgY2lwaGVyPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwYXNzcGhyYXNlPzogc3RyaW5nIHwgQnVmZmVyIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEp3a0tleUV4cG9ydE9wdGlvbnMge1xuICBmb3JtYXQ6IFwiandrXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0tleU9iamVjdChvYmo6IHVua25vd24pOiBvYmogaXMgS2V5T2JqZWN0IHtcbiAgcmV0dXJuIGlzS2V5T2JqZWN0XyhvYmopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDcnlwdG9LZXkoXG4gIG9iajogdW5rbm93bixcbik6IG9iaiBpcyB7IHR5cGU6IHN0cmluZzsgW2tLZXlPYmplY3RdOiBLZXlPYmplY3QgfSB7XG4gIHJldHVybiBpc0NyeXB0b0tleV8ob2JqKTtcbn1cblxuZXhwb3J0IGNsYXNzIEtleU9iamVjdCB7XG4gIFtrS2V5VHlwZV06IEtleU9iamVjdFR5cGU7XG4gIFtrSGFuZGxlXTogdW5rbm93bjtcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBLZXlPYmplY3RUeXBlLCBoYW5kbGU6IHVua25vd24pIHtcbiAgICBpZiAodHlwZSAhPT0gXCJzZWNyZXRcIiAmJiB0eXBlICE9PSBcInB1YmxpY1wiICYmIHR5cGUgIT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFwiaGFuZGxlXCIsIFwib2JqZWN0XCIsIGhhbmRsZSk7XG4gICAgfVxuXG4gICAgdGhpc1trS2V5VHlwZV0gPSB0eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtIYW5kbGUsIHtcbiAgICAgIHZhbHVlOiBoYW5kbGUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgdHlwZSgpOiBLZXlPYmplY3RUeXBlIHtcbiAgICByZXR1cm4gdGhpc1trS2V5VHlwZV07XG4gIH1cblxuICBnZXQgYXN5bW1ldHJpY0tleURldGFpbHMoKTogQXN5bW1ldHJpY0tleURldGFpbHMgfCB1bmRlZmluZWQge1xuICAgIG5vdEltcGxlbWVudGVkKFwiY3J5cHRvLktleU9iamVjdC5wcm90b3R5cGUuYXN5bW1ldHJpY0tleURldGFpbHNcIik7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IGFzeW1tZXRyaWNLZXlUeXBlKCk6IEtleVR5cGUgfCB1bmRlZmluZWQge1xuICAgIG5vdEltcGxlbWVudGVkKFwiY3J5cHRvLktleU9iamVjdC5wcm90b3R5cGUuYXN5bW1ldHJpY0tleVR5cGVcIik7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IHN5bW1ldHJpY0tleVNpemUoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBub3RJbXBsZW1lbnRlZChcImNyeXB0by5LZXlPYmplY3QucHJvdG90eXBlLnN5bW1ldHJpY0tleVNpemVcIik7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3RhdGljIGZyb20oa2V5OiBDcnlwdG9LZXkpOiBLZXlPYmplY3Qge1xuICAgIGlmICghaXNDcnlwdG9LZXkoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFwia2V5XCIsIFwiQ3J5cHRvS2V5XCIsIGtleSk7XG4gICAgfVxuXG4gICAgbm90SW1wbGVtZW50ZWQoXCJjcnlwdG8uS2V5T2JqZWN0LnByb3RvdHlwZS5mcm9tXCIpO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyS2V5T2JqZWN0OiBLZXlPYmplY3QpOiBib29sZWFuIHtcbiAgICBpZiAoIWlzS2V5T2JqZWN0KG90aGVyS2V5T2JqZWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICBcIm90aGVyS2V5T2JqZWN0XCIsXG4gICAgICAgIFwiS2V5T2JqZWN0XCIsXG4gICAgICAgIG90aGVyS2V5T2JqZWN0LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBub3RJbXBsZW1lbnRlZChcImNyeXB0by5LZXlPYmplY3QucHJvdG90eXBlLmVxdWFsc1wiKTtcbiAgfVxuXG4gIGV4cG9ydChvcHRpb25zOiBLZXlFeHBvcnRPcHRpb25zPFwicGVtXCI+KTogc3RyaW5nIHwgQnVmZmVyO1xuICBleHBvcnQob3B0aW9ucz86IEtleUV4cG9ydE9wdGlvbnM8XCJkZXJcIj4pOiBCdWZmZXI7XG4gIGV4cG9ydChvcHRpb25zPzogSndrS2V5RXhwb3J0T3B0aW9ucyk6IEpzb25XZWJLZXk7XG4gIGV4cG9ydChfb3B0aW9ucz86IHVua25vd24pOiBzdHJpbmcgfCBCdWZmZXIgfCBKc29uV2ViS2V5IHtcbiAgICBub3RJbXBsZW1lbnRlZChcImNyeXB0by5LZXlPYmplY3QucHJvdG90eXBlLmFzeW1tZXRyaWNLZXlUeXBlXCIpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnNvbldlYktleUlucHV0IHtcbiAga2V5OiBKc29uV2ViS2V5O1xuICBmb3JtYXQ6IFwiandrXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcml2YXRlS2V5KFxuICBfa2V5OiBQcml2YXRlS2V5SW5wdXQgfCBzdHJpbmcgfCBCdWZmZXIgfCBKc29uV2ViS2V5SW5wdXQsXG4pOiBLZXlPYmplY3Qge1xuICBub3RJbXBsZW1lbnRlZChcImNyeXB0by5jcmVhdGVQcml2YXRlS2V5XCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHVibGljS2V5KFxuICBfa2V5OiBQdWJsaWNLZXlJbnB1dCB8IHN0cmluZyB8IEJ1ZmZlciB8IEtleU9iamVjdCB8IEpzb25XZWJLZXlJbnB1dCxcbik6IEtleU9iamVjdCB7XG4gIG5vdEltcGxlbWVudGVkKFwiY3J5cHRvLmNyZWF0ZVB1YmxpY0tleVwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5VHlwZXMoYWxsb3dLZXlPYmplY3Q6IGJvb2xlYW4sIGJ1ZmZlck9ubHkgPSBmYWxzZSkge1xuICBjb25zdCB0eXBlcyA9IFtcbiAgICBcIkFycmF5QnVmZmVyXCIsXG4gICAgXCJCdWZmZXJcIixcbiAgICBcIlR5cGVkQXJyYXlcIixcbiAgICBcIkRhdGFWaWV3XCIsXG4gICAgXCJzdHJpbmdcIiwgLy8gT25seSBpZiBidWZmZXJPbmx5ID09IGZhbHNlXG4gICAgXCJLZXlPYmplY3RcIiwgLy8gT25seSBpZiBhbGxvd0tleU9iamVjdCA9PSB0cnVlICYmIGJ1ZmZlck9ubHkgPT0gZmFsc2VcbiAgICBcIkNyeXB0b0tleVwiLCAvLyBPbmx5IGlmIGFsbG93S2V5T2JqZWN0ID09IHRydWUgJiYgYnVmZmVyT25seSA9PSBmYWxzZVxuICBdO1xuICBpZiAoYnVmZmVyT25seSkge1xuICAgIHJldHVybiB0eXBlcy5zbGljZSgwLCA0KTtcbiAgfSBlbHNlIGlmICghYWxsb3dLZXlPYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZXMuc2xpY2UoMCwgNSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVNlY3JldEtleShcbiAga2V5OiBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IEtleU9iamVjdCxcbiAgZW5jb2Rpbmc6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgYnVmZmVyT25seSA9IGZhbHNlLFxuKSB7XG4gIGlmICghYnVmZmVyT25seSkge1xuICAgIGlmIChpc0tleU9iamVjdChrZXkpKSB7XG4gICAgICBpZiAoa2V5LnR5cGUgIT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9DUllQVE9fSU5WQUxJRF9LRVlfT0JKRUNUX1RZUEUoa2V5LnR5cGUsIFwic2VjcmV0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleVtrSGFuZGxlXTtcbiAgICB9IGVsc2UgaWYgKGlzQ3J5cHRvS2V5KGtleSkpIHtcbiAgICAgIGlmIChrZXkudHlwZSAhPT0gXCJzZWNyZXRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0NSWVBUT19JTlZBTElEX0tFWV9PQkpFQ1RfVFlQRShrZXkudHlwZSwgXCJzZWNyZXRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5W2tLZXlPYmplY3RdW2tIYW5kbGVdO1xuICAgIH1cbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICFpc0FycmF5QnVmZmVyVmlldyhrZXkpICYmXG4gICAgIWlzQW55QXJyYXlCdWZmZXIoa2V5KVxuICApIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICBcImtleVwiLFxuICAgICAgZ2V0S2V5VHlwZXMoIWJ1ZmZlck9ubHksIGJ1ZmZlck9ubHkpLFxuICAgICAga2V5LFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZ2V0QXJyYXlCdWZmZXJPclZpZXcoa2V5LCBcImtleVwiLCBlbmNvZGluZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWNyZXRLZXkoa2V5OiBBcnJheUJ1ZmZlclZpZXcpOiBLZXlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VjcmV0S2V5KFxuICBrZXk6IHN0cmluZyxcbiAgZW5jb2Rpbmc6IHN0cmluZyxcbik6IEtleU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWNyZXRLZXkoXG4gIF9rZXk6IHN0cmluZyB8IEFycmF5QnVmZmVyVmlldyxcbiAgX2VuY29kaW5nPzogc3RyaW5nLFxuKTogS2V5T2JqZWN0IHtcbiAgbm90SW1wbGVtZW50ZWQoXCJjcnlwdG8uY3JlYXRlU2VjcmV0S2V5XCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNyZWF0ZVByaXZhdGVLZXksXG4gIGNyZWF0ZVB1YmxpY0tleSxcbiAgY3JlYXRlU2VjcmV0S2V5LFxuICBpc0tleU9iamVjdCxcbiAgaXNDcnlwdG9LZXksXG4gIEtleU9iamVjdCxcbiAgcHJlcGFyZVNlY3JldEtleSxcbn07XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBQzFFLHFGQUFxRjtBQUVyRixTQUFTLE9BQU8sRUFBRSxVQUFVLFFBQVEsaUJBQWlCO0FBQ3JELFNBQ0Usa0NBQWtDLEVBQ2xDLG9CQUFvQixFQUNwQixxQkFBcUIsUUFDaEIsZUFBZTtBQUN0QixTQUFTLGNBQWMsUUFBUSxrQkFBa0I7QUFPakQsU0FBUyxNQUFNLFFBQVEsa0JBQWtCO0FB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